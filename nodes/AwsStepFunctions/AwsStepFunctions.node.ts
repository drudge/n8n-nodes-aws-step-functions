import { IExecuteFunctions } from 'n8n-core';
import {
	ICredentialDataDecryptedObject,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
	NodeOperationError,
} from 'n8n-workflow';

import * as AWS from 'aws-sdk';

export class AwsStepFunctions implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'AWS Step Functions',
		name: 'awsStepFunctions',
		icon: 'file:stepfunctions.svg',
		group: ['transform'],
		version: 1,
		description: 'Consume the AWS Step Functions API',
		subtitle: '={{$parameter["operation"]}}',
		defaults: {
			name: 'AWS Step Functions',
		},
		inputs: ['main'],
		outputs: ['main'],
		credentials: [
			{
				name: 'aws',
				required: true,
			},
		],
		properties: [
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				options: [
					{
						name: 'Describe Execution',
						value: 'describeExecution',
						action: 'Describe an execution',
					},
					{
						name: 'Describe State Machine',
						value: 'describeStateMachine',
						action: 'Describes a state machine',
					},
					{
						name: 'Describe State Machine for Execution',
						value: 'describeStateMachineForExecution',
						action: 'Describes the state machine associated with a specific execution',
					},
					{
						name: 'Send Task Failure',
						value: 'sendTaskFailure',
						action: 'Report that the task identified by the task token failed',
					},
					{
						name: 'Send Task Heartbeat',
						value: 'sendTaskHeartbeat',
						action: 'Report to step functions that the task represented by the specified task token is still making progress',
					},
					{
						name: 'Send Task Success',
						value: 'sendTaskSuccess',
						action: 'Report that the task identified by the task token completed successfully',
					},
					{
						name: 'Start Execution',
						value: 'startExecution',
						action: 'Starts a state machine execution',
					},
					{
						name: 'Stop Execution',
						value: 'stopExecution',
						action: 'Stops a state machine execution',
					},
				],
				default: 'describeExecution',
			},
			{
				displayName: 'Execution ARN',
				name: 'executionArn',
				type: 'string',
				required: true,
				default: '',
				description: 'The Amazon Resource Name (ARN) of the execution to describe',
				displayOptions: {
					show: {
						operation: [
							'describeExecution',
							'describeStateMachineForExecution',
							'stopExecution',
						],
					},
				},
			},
			{
				displayName: 'State Machine ARN',
				name: 'stateMachineArn',
				type: 'string',
				required: true,
				default: '',
				description: 'The Amazon Resource Name (ARN) of the state machine to describe',
				displayOptions: {
					show: {
						operation: [
							'describeStateMachine',
							'startExecution',
						],
					},
				},
			},
			{
				displayName: 'Task Token',
				name: 'taskToken',
				type: 'string',
				default: '',
				description: 'The token that represents this task. Task tokens are generated by Step Functions when tasks are assigned to a worker, or in the context object when a workflow enters a task state.',
				displayOptions: {
					show: {
						operation: [
							'sendTaskFailure',
							'sendTaskHeartbeat',
							'sendTaskSuccess',
						],
					},
				},
			},
			{
				displayName: 'Name',
				name: 'name',
				type: 'string',
				default: '',
				description: 'The name of the execution. This name must be unique for your AWS account, region, and state machine for 90 days.',
				displayOptions: {
					show: {
						operation: [
							'startExecution',
						],
					},
				},
			},
			{
				displayName: 'Input',
				name: 'input',
				type: 'json',
				default: '{}',
				description: 'The string that contains the JSON input data for the execution',
				displayOptions: {
					show: {
						operation: [
							'startExecution',
						],
					},
				},
			},
			{
				displayName: 'Output',
				name: 'output',
				type: 'json',
				default: '{}',
				description: 'The JSON output of the task. Length constraints apply to the payload size, and are expressed as bytes in UTF-8 encoding.',
				displayOptions: {
					show: {
						operation: [
							'sendTaskSuccess',
						],
					},
				},
			},
			{
				displayName: 'Error',
				name: 'error',
				type: 'string',
				default: '',
				description: 'The error code of the failure',
				displayOptions: {
					show: {
						operation: [
							'stopExecution',
							'sendTaskFailure',
						],
					},
				},
			},
			{
				displayName: 'Cause',
				name: 'cause',
				type: 'string',
				default: '',
				description: 'A more detailed explanation of the cause of the failure',
				displayOptions: {
					show: {
						operation: [
							'stopExecution',
							'sendTaskFailure',
						],
					},
				},
			},
		],
	};

	// The function below is responsible for actually doing whatever this node
	// is supposed to do. In this case, we're just appending the `myString` property
	// with whatever the user has entered.
	// You can make async calls and use `await`.
	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const credentials: ICredentialDataDecryptedObject = await this.getCredentials('aws');
		const stepFunctions = new AWS.StepFunctions({
			accessKeyId: `${credentials.accessKeyId}`.trim(),
			secretAccessKey: `${credentials.secretAccessKey}`.trim(),
			region: `${credentials.region}`.trim(),
		});

		let item: INodeExecutionData;

		// Iterates over all input items and add the key "myString" with the
		// value the parameter "myString" resolves to.
		// (This could be a different value for each item in case it contains an expression)
		for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
			try {
				const operation = this.getNodeParameter('operation', itemIndex) as string;

				item = items[itemIndex];

				if (operation === 'describeExecution') {
					const executionArn = this.getNodeParameter('executionArn', itemIndex) as string;
					const result = await stepFunctions.describeExecution({
						executionArn,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'describeStateMachineForExecution') {
					const executionArn = this.getNodeParameter('executionArn', itemIndex) as string;
					const result = await stepFunctions.describeStateMachineForExecution({
						executionArn,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'describeStateMachine') {
					const stateMachineArn = this.getNodeParameter('stateMachineArn', itemIndex) as string;
					const result = await stepFunctions.describeStateMachine({
						stateMachineArn,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'startExecution') {
					const stateMachineArn = this.getNodeParameter('stateMachineArn', itemIndex) as string;
					const name = this.getNodeParameter('name', itemIndex) as string;
					const input = this.getNodeParameter('input', itemIndex, '{}') as string;
					const result = await stepFunctions.startExecution({
						stateMachineArn,
						name: name ? name : undefined,
						input,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'stopExecution') {
					const executionArn = this.getNodeParameter('executionArn', itemIndex) as string;
					const error = this.getNodeParameter('error', itemIndex) as string;
					const cause = this.getNodeParameter('cause', itemIndex) as string;
					const result = await stepFunctions.stopExecution({
						executionArn,
						error: error ? error : undefined,
						cause: cause ? cause : undefined,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'sendTaskFailure') {
					const taskToken = this.getNodeParameter('taskToken', itemIndex) as string;
					const error = this.getNodeParameter('error', itemIndex) as string;
					const cause = this.getNodeParameter('cause', itemIndex) as string;
					const result = await stepFunctions.sendTaskFailure({
						taskToken,
						error: error ? error : undefined,
						cause: cause ? cause : undefined,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'sendTaskHeartbeat') {
					const taskToken = this.getNodeParameter('taskToken', itemIndex) as string;
					const result = await stepFunctions.sendTaskHeartbeat({
						taskToken,
					}).promise();
					item.json = { ...result };
				} else if (operation === 'sendTaskSuccess') {
					const taskToken = this.getNodeParameter('taskToken', itemIndex) as string;
					const output = this.getNodeParameter('output', itemIndex) as string;
					const result = await stepFunctions.sendTaskSuccess({
						taskToken,
						output,
					}).promise();
					item.json = { ...result };
				}
			} catch (error) {
				// This node should never fail but we want to showcase how
				// to handle errors.
				if (this.continueOnFail()) {
					items.push({ json: this.getInputData(itemIndex)[0].json, error, pairedItem: itemIndex });
				} else {
					// Adding `itemIndex` allows other workflows to handle this error
					if (error.context) {
						// If the error thrown already contains the context property,
						// only append the itemIndex
						error.context.itemIndex = itemIndex;
						throw error;
					}
					throw new NodeOperationError(this.getNode(), error, {
						itemIndex,
					});
				}
			}
		}

		return this.prepareOutputData(items);
	}
}
